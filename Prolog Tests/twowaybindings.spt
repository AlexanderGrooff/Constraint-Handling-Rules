module twowaybindings

language Prolog

test single two way [[
	a(Z) :- b(Z).
	b(c).

	?- a(X).
]] run evaluate-full to Result("true", [("X", Atom("c"))])

test multiple two way [[
	a(X, Y) :- b(X), c(Y).
	b(1).
	c(2).
	
	?- a(Z1, Z2).
]] run evaluate-full to Result("true", [("Z1", Int("1")), ("Z2", Int("2"))])

test same local variable [[
	a(X, X).
	
	?- a(Y, b).
]] run evaluate-full to Result("true", [("Y", Atom("b"))])

test same local variable reversed [[
	a(X, X).
	
	?- a(b, Y).
]] run evaluate-full to Result("true", [("Y", Atom("b"))])

test same local variable resolved [[
	a(X, X) :- b(X).
	b(c).
	
	?- a(Y, Z).
]] run evaluate-full to Result("true", [("Y", Atom("c")), ("Z", Atom("c"))])

test same free variable [[
	a(Y, b).
	
	?- a(X, X).
]] run evaluate-full to Result("true", [("X", Atom("b"))])

test same free variable reversed [[
	a(b, Y).
	
	?- a(X, X).
]] run evaluate-full to Result("true", [("X", Atom("b"))])

test same free variable resolved [[
	a(Y, Z) :- b(Z, Y).
	b(1, 2).
	b(2, 1).
	b(2, 2).
	
	?- a(X, X).
]] run evaluate-full to Result("true", [("X", Int("2"))])

test mixed same local and free variables [[
	a(F1, F1, F2) :- b(F1, F2).
	b(1, 2).
	b(2, 1).
	b(1, 1).
	
	?- a(G1, G2, G2).
]] run evaluate-full to Result("true", [("G1", Int("1")), ("G2", Int("1"))])

test single inner binding [[
	a(b(Z)) :- c(Z).
	c(d).
	
	?- a(Y).
]] run evaluate-full to Result("true", [("Y", ComoundTerm("b", [Atom("d")]))])

test single outer binding [[
	a(Z) :- c(Z).
	c(b(d)).
	
	?- a(b(Y)).
]] run evaluate-full to Result("true", [("Y", Atom("d"))])