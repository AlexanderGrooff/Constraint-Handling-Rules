module evaluation

imports
  src-gen/signatures/-
  desugar

rules
  args-unify: ([arg1|args1*], [arg2|args2*], store*) -> <args-unify> (args1*, args2*, store2*)
    where store2* := <unify> (arg1, arg2, store*)
  args-unify: ([], [], store*) -> store*
  
  lookup-store: (x, []) -> $[var [x] not found]
  lookup-store: (x, [(x, val) | store*]) -> val
  lookup-store: (x, [_ | store*]) -> <lookup-store> (x, store*)
  
  substitute: (Atom(x), store*) -> Atom(x)
  substitute: (Int(x), store*) -> Int(x)
  substitute: (Float(x), store*) -> Float(x)
  substitute: (CompoundTerm(x, args*), store*) -> <substitute-list> (args*, store*)
  substitute: (Var(x), store*) -> <lookup-store> (x, store*)
  substitute-list: ([], store*) -> []
  substitute-list: ([arg | args*], store*) -> [<substitute> (arg, store*) | <substitute-list> (args*, store*)]
  

  unify: (Atom(x), Atom(x), store*) -> store*
  unify: (Int(x), Int(x), store*) -> store*
  unify: (Float(x), Float(x), store*) -> store*
  unify: (String(x), String(x), store*) -> store*
  unify: (Atom(x), String(x), store*) -> store*
  unify: (String(x), Atom(x), store*) -> store*
  unify: (CompoundTerm(x, args1*), CompoundTerm(x, args2*), store*) -> <args-unify> (args1*, args2*, store*)
    where <eq>(<length> args1*, <length> args2*)
  unify: (Var(x), goal, store*) -> [(x,goal)|store*]

  unify(|rulls*): (_, Atom("true")) -> "true"
  unify(|rulls*): ([Rule(head, body) | remainingrules*], goal) -> <unify(|rulls*)> (rulls*, subgoal)
    where store*  := <unify> (head, goal);
          subgoal := <substitute> (body, store*)
  unify(|rulls*): ([Rule(head, body) | remainingrules*], goal) -> <unify(|rulls*)> (remainingrules*, goal)
//unify(|rulls*): ([], _) -> <fail>

		

  evaluate-full: (rulls*, Query(goal)) -> <unify(|desugared-rules*)> (desugared-rules*, <desugar-all>goal)
  	where
  		desugared-rules* := <desugar-all> rulls*
