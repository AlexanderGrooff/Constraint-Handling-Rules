module evaluation

imports
  src-gen/signatures/-
  desugar

signature
  constructors
    Result: STRING * List -> Result

rules
  args-unify: ([arg1|args1*], [arg2|args2*], local-store*, free-store*) -> <args-unify> (args1*, args2*, local-store2*, free-store2*)
    where (local-store2*, free-store2*) := <unify> (arg1, arg2, local-store*, free-store*)
  args-unify: ([], [], local-store*, free-store*) -> (local-store*, free-store*)
  
  lookup-store: (x, []) -> Var(x)
//	with <debug> $[var [x] not found]
  lookup-store: (x, [(x, val) | store*]) -> val
//	with <debug> $[found value for [x]]
  lookup-store: (x, [_ | store*]) -> <lookup-store> (x, store*)
  
  make-unique(|uid): Var(x) -> Var((uid, x))
  
  substitute(|store*): Var(x) -> <lookup-store> (x, store*)
  
  substitute-all(|store*) = topdown(try(substitute(|store*)))
  
  unify-var: (x, value, store*) -> [(x, value), (x, found) | store*]
  	where <fetch(?(x, Var(found)))> store*
  unify-var: (x, value, store*) -> store*
    where <fetch(?(x, found))> store*;
          <eq> (found, value)
//	with <debug> $[Previous definition of [x] found with same value]
  unify-var: (x, value, store*) -> [(x, value) |store*]
    where <not(fetch(?(x, _)))> store*
//	with <debug> $[No previous definition found of [x]]

  unify: (Atom(x), Atom(x), local-store*, free-store*) -> (local-store*, free-store*)
  unify: (Int(x), Int(x), local-store*, free-store*) -> (local-store*, free-store*)
  unify: (Float(x), Float(x), local-store*, free-store*) -> (local-store*, free-store*)
  unify: (String(x), String(x), local-store*, free-store*) -> (local-store*, free-store*)
  unify: (Atom(x), String(x), local-store*, free-store*) -> (local-store*, free-store*)
  unify: (String(x), Atom(x), local-store*, free-store*) -> (local-store*, free-store*)
  unify: (CompoundTerm(x, args1*), CompoundTerm(x, args2*), local-store*, free-store*) -> <args-unify> (args1*, args2*, local-store*, free-store*)
    where <eq>(<length> args1*, <length> args2*)
  unify: (ListCon(head1, tail1), ListCon(head2, tail2), local-store*, free-store*) -> <unify> (tail1, tail2, local-store2*, free-store2*)
    where (local-store2*, free-store2*) := <unify> (head1, head2, local-store*, free-store*)
  unify: (ListNil(), ListNil(), local-store*, free-store*) -> (local-store*, free-store*)
  unify: (Wildcard(), _, local-store*, free-store*) -> (local-store*, free-store*)
  unify: (_, Wildcard(), local-store*, free-store*) -> (local-store*, free-store*)
  unify: (Var(x), goal, local-store*, free-store*) -> (new-store*, free-store*)
    where new-store* := <unify-var> (x, goal, local-store*)
  unify: (head, Var(x), local-store*, free-store*) -> (local-store*, new-store*)
    where new-store* := <unify-var> (x, head, free-store*)

  evaluate(|rulls*): (_, Atom("true")) -> Result("true", [])
  evaluate(|rulls*): (remainingrules*, Conj(goal1, goal2)) -> Result("true", <conc> (store*, store2*))
    where Result(str, store*) := <evaluate(|rulls*)> (remainingrules*, goal1);
          <eq>(str, "true");
          <debug> $[Evaluating second part of Conj];
          Result(str2, store2*) := <evaluate(|rulls*)> (rulls*, <substitute-all(|store*)> goal2);
          <eq>(str2, "true")
  evaluate(|rulls*): ([Rule(_, _) | remainingrules*], Conj(goal1, goal2)) -> <evaluate(|rulls*)> (remainingrules*, Conj(goal1, goal2))
  evaluate(|rulls*): (_, Disj(goal1, goal2)) -> Result("true", store*)
    where Result(str, store*) := <evaluate(|rulls*)> (rulls*, goal1);
          <eq>(str, "true")
  evaluate(|rulls*): (_, Disj(goal1, goal2)) -> Result("true", store*)
    where Result(str, store*) := <evaluate(|rulls*)> (rulls*, goal2);
          <eq>(str, "true")
  evaluate(|rulls*): (_, Disj(goal1, goal2)) -> Result("false", [])
  evaluate(|rulls*): (_, Neg(goal)) -> Result("false", store*)
    where Result(str, store*) := <evaluate(|rulls*)> (rulls*, goal);
          <eq>(str, "true")
  evaluate(|rulls*): (_, Neg(goal)) -> Result("true", [])
  evaluate(|rulls*): ([Rule(head, body) | remainingrules*], goal) -> Result(r, <conc> (<substitute-all(|free-store2*)> free-store*, free-store2*))
    where 
      uid := <new>;
      (u-head, u-body) := <topdown(try(make-unique(|uid)))> (head, body);
      <debug>$[Unify args: ];
      <debug>(u-head, goal);
      (local-store*, free-store*) := <unify> (u-head, goal, [], []);
      <debug>$[Local store:];
      <debug>local-store*;
      <debug>$[Free store:];
      <debug>free-store*;
      subgoal := <substitute-all(|local-store*)> u-body;
      <debug>$[Substitute result:];
      <debug>subgoal;
      Result(r, free-store2*) := <evaluate(|rulls*)> (rulls*, subgoal);
      <debug>$[Free store 2:];
      <debug>free-store2*
  evaluate(|rulls*): ([Rule(_, _) | remainingrules*], goal) -> <evaluate(|rulls*)> (remainingrules*, goal)
  evaluate(|rulls*): ([], _) -> Result("false", [])

  evaluate-full: (rulls*, Query(goal)) -> <evaluate(|desugared-rules*)> (desugared-rules*, <desugar-all> goal)
  	with
      desugared-rules* := <desugar-all> rulls*
