module evaluation

imports
  src-gen/signatures/-
  desugar

rules
  args-unify: ([arg1|args1*], [arg2|args2*], local-store*, free-store*) -> <args-unify> (args1*, args2*, local-store2*, free-store2*)
    where (local-store2*, free-store2*) := <unify> (arg1, arg2, local-store*, free-store*)
  args-unify: ([], [], local-store*, free-store*) -> (local-store*, free-store*)
  
  lookup-store: (x, []) -> Var(x)
//	with <debug> $[var [x] not found]
  lookup-store: (x, [(x, val) | store*]) -> val
//	with <debug> $[found value for [x]]
  lookup-store: (x, [_ | store*]) -> <lookup-store> (x, store*)
  
  make-unique(|uid): Var(x) -> Var((uid, x))
  
  substitute(|store*): Var(x) -> <lookup-store> (x, store*)
  
  substitute-all(|store*) = topdown(try(substitute(|store*)))
  
  unify-var: (x, value, store*) -> store*
    where <fetch(?(x, found))> store*;
          <eq> (found, value)
//	with <debug> $[Previous definition of [x] found with same value]
  unify-var: (x, value, store*) -> [(x, value) |store*]
    where <not(fetch(?(x, _)))> store*
//	with <debug> $[No previous definition found of [x]]

  unify: (Atom(x), Atom(x), local-store*, free-store*) -> (local-store*, free-store*)
  unify: (Int(x), Int(x), local-store*, free-store*) -> (local-store*, free-store*)
  unify: (Float(x), Float(x), local-store*, free-store*) -> (local-store*, free-store*)
  unify: (String(x), String(x), local-store*, free-store*) -> (local-store*, free-store*)
  unify: (Atom(x), String(x), local-store*, free-store*) -> (local-store*, free-store*)
  unify: (String(x), Atom(x), local-store*, free-store*) -> (local-store*, free-store*)
  unify: (CompoundTerm(x, args1*), CompoundTerm(x, args2*), local-store*, free-store*) -> <args-unify> (args1*, args2*, local-store*, free-store*)
    where <eq>(<length> args1*, <length> args2*)
  unify: (Var(x), goal, local-store*, free-store*) -> (new-store*, free-store*)
    where new-store* := <unify-var> (x, goal, local-store*)
  unify: (head, Var(x), local-store*, free-store*) -> (local-store*, new-store*)
    where new-store* := <unify-var> (x, head, free-store*)

  evaluate(|rulls*): (_, Atom("true")) -> ("true", [])
  evaluate(|rulls*): (remainingrules*, Conj(goal1, goal2)) -> ("true", <conc> (store*, store2*))
    where (str, store*) := <evaluate(|rulls*)> (remainingrules*, goal1);
    	<eq>(str, "true");
    	<debug> $[Evaluating second part of Conj];
      	(str2, store2*) := <evaluate(|rulls*)> (rulls*, <substitute-all(|store*)> goal2);
      	<eq>(str2, "true")
  evaluate(|rulls*): ([Rule(_, _) | remainingrules*], Conj(goal1, goal2)) -> <evaluate(|rulls*)> (remainingrules*, Conj(goal1, goal2))
  evaluate(|rulls*): (_, Disj(goal1, goal2)) -> ("true", store*)
    where (str, store*) := <evaluate(|rulls*)> (rulls*, goal1);
    	<eq>(str, "true")
  evaluate(|rulls*): (_, Disj(goal1, goal2)) -> ("true", store*)
    where (str, store*) := <evaluate(|rulls*)> (rulls*, goal2);
    	<eq>(str, "true")
  evaluate(|rulls*): (_, Disj(goal1, goal2)) -> ("false", [])
  evaluate(|rulls*): (_, Neg(goal)) -> ("false", store*)
    where (str, store*) := <evaluate(|rulls*)> (rulls*, goal);
    	<eq>(str, "true")
  evaluate(|rulls*): (_, Neg(goal)) -> ("true", [])
  evaluate(|rulls*): ([Rule(head, body) | remainingrules*], goal) -> (r, <conc> (<substitute-all(|free-store2*)> free-store*, free-store2*))
    where 
    	uid := <new>;
    	(u-head, u-body) := <topdown(try(make-unique(|uid)))> (head, body);
    	<debug>$[Unify args: ];
    	<debug>(u-head, goal);
    	(local-store*, free-store*) := <unify> (u-head, goal, [], []);
    	<debug>$[Local store:];
    	<debug>local-store*;
    	<debug>$[Free store:];
    	<debug>free-store*;
      	subgoal := <substitute-all(|local-store*)> u-body;
    	<debug>$[Substitute result:];
    	<debug>subgoal;
    	(r, free-store2*) := <evaluate(|rulls*)> (rulls*, subgoal);
    	<debug>$[Free store 2:];
    	<debug>free-store2*
  evaluate(|rulls*): ([Rule(_, _) | remainingrules*], goal) -> <evaluate(|rulls*)> (remainingrules*, goal)
  evaluate(|rulls*): ([], _) -> ("false", [])

  evaluate-full: (rulls*, Query(goal)) -> <evaluate(|desugared-rules*)> (desugared-rules*, <desugar-all> goal)
  	with
  		desugared-rules* := <desugar-all> rulls*
