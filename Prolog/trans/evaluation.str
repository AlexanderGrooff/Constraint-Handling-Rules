module evaluation

imports
  src-gen/signatures/-
  desugar

rules
  args-unify: ([arg1|args1*], [arg2|args2*], store*) -> <args-unify> (args1*, args2*, store2*)
    where store2* := <unify> (arg1, arg2, store*)
  args-unify: ([], [], store*) -> store*

  unify: (Atom(x), Atom(x), store*) -> store*
  unify: (Int(x), Int(x), store*) -> store*
  unify: (Float(x), Float(x), store*) -> store*
  unify: (String(x), String(x), store*) -> store*
  unify: (Atom(x), String(x), store*) -> store*
  unify: (String(x), Atom(x), store*) -> store*
  unify: (CompoundTerm(x, args1*), CompoundTerm(x, args2*), store*) -> <args-unify> (args1*, args2*, store*)
    where <eq>(<length> args1*, <length> args2*)
  unify: (Var(x), goal, store*) -> [(x,goal)|store*]

  unify(|rulls*): (_, Atom("true")) -> "true"
  unify(|rulls*): ([Rule(head, body) | remainingrules*], goal) -> <unify(|rulls*)> (rulls*, subgoal)
    where store*  := <unify> (head, goal);
          subgoal := <substitute> (body, store*)
  unify(|rulls*): ([Rule(head, body) | remainingrules*], goal) -> <unify(|rulls*)> (remainingrules*, goal)
//unify(|rulls*): ([], _) -> <fail>

//bind-vars: ([], []) -> []
//bind-vars: ([arg | args*], [Var(args2) | args2*]) -> [arg | <bind-vars> (args*, args2*)]
//bind-vars: ([arg | args*], [arg2 | args2*]) -> [arg2 | <bind-vars> (args*, args2*)]
		

  evaluate-full: (rulls*, Query(goal)) -> <unify(|desugared-rules*)> (desugared-rules*, <desugar-all>goal)
  	where
  		desugared-rules* := <desugar-all> rulls*
