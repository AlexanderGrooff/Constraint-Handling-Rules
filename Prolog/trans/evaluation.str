module evaluation

imports
  src-gen/signatures/-
  desugar

rules
  args-unify: ([arg1|args1*], [arg2|args2*], store*) -> <args-unify> (args1*, args2*, store2*)
    where store2* := <unify> (arg1, arg2, store*)
  args-unify: ([], [], store*) -> store*
  
  lookup-store: (x, []) -> Var(x)
  	with <debug> $[var [x] not found]
  lookup-store: (x, [(x, val) | store*]) -> val
  lookup-store: (x, [_ | store*]) -> <lookup-store> (x, store*)
  
  substitute: (Atom(x), store*) -> Atom(x)
  substitute: (Int(x), store*) -> Int(x)
  substitute: (Float(x), store*) -> Float(x)
  substitute: (CompoundTerm(x, args*), store*) -> CompoundTerm(x, <substitute-list> (args*, store*))
  substitute: (Var(x), store*) -> <lookup-store> (x, store*)
  substitute: (String(x), store*) -> String(x)
  substitute: (Conj(a, b), store*) -> Conj(<substitute> (a, store*), <substitute> (b, store*))
  substitute-list: ([], store*) -> []
  substitute-list: ([arg | args*], store*) -> [<substitute> (arg, store*) | <substitute-list> (args*, store*)]
  
  unify-var: (Var(x), value, []) -> (x, value)
  	with <debug> $[No previous definition found of [x]]
  unify-var: (Var(x), value, [(x, value) | store*]) -> []
//  unify-var: (Var(x), value, [(x, value2) | store*]) -> <fail>
//  	with <debug> $[unify should fail]
  unify-var: (Var(x), value, [(t, _) | store*]) -> <unify-var> (Var(x), value, store*)
    where 
      <not(?t)> x

  unify: (Atom(x), Atom(x), store*) -> store*
  unify: (Int(x), Int(x), store*) -> store*
  unify: (Float(x), Float(x), store*) -> store*
  unify: (String(x), String(x), store*) -> store*
  unify: (Atom(x), String(x), store*) -> store*
  unify: (String(x), Atom(x), store*) -> store*
  unify: (CompoundTerm(x, args1*), CompoundTerm(x, args2*), store*) -> <args-unify> (args1*, args2*, store*)
    where <eq>(<length> args1*, <length> args2*)
  unify: (Var(x), goal, store*) -> [<unify-var> (Var(x), goal, store*) |store*]
  unify: (head, Var(x), store*) -> [<unify-var> (Var(x), head, store*) |store*]

  unify(|rulls*): (_, Atom("true"), store*) -> "true"
  unify(|rulls*): (_, Conj(goal1, goal2), store*) -> "true"
    where <unify(|rulls*);?"true"> (rulls*, goal1, store*);
          <unify(|rulls*);?"true"> (rulls*, goal2, store*)
  unify(|rulls*): (_, Conj(goal1, goal2), store*) -> "false"
  unify(|rulls*): (_, Disj(goal1, goal2), store*) -> "true"
    where <unify(|rulls*);?"true"> (rulls*, goal1, store*)
  unify(|rulls*): (_, Disj(goal1, goal2), store*) -> "true"
    where <unify(|rulls*);?"true"> (rulls*, goal2, store*)
  unify(|rulls*): (_, Disj(goal1, goal2), store*) -> "false"
  unify(|rulls*): (_, Neg(goal), store*) -> "false"
    where <unify(|rulls*);?"true"> (rulls*, goal, store*)
  unify(|rulls*): (_, Neg(goal), store*) -> "true"
  unify(|rulls*): ([Rule(head, body) | remainingrules*], goal, store*) -> <unify(|rulls*)> (rulls*, subgoal, store*)
    where new-store*  := <debug><debug;unify> (head, goal, store*);
          subgoal := <debug><debug;substitute>(body, new-store*)
  unify(|rulls*): ([Rule(head, body) | remainingrules*], goal, store*) -> <unify(|rulls*)> (remainingrules*, goal, store*)
  unify(|rulls*): ([], _, store*) -> "false"

		

  evaluate-full: (rulls*, Query(goal)) -> <unify(|desugared-rules*)> (desugared-rules*, <desugar-all>goal, [])
  	with
  		desugared-rules* := <desugar-all> rulls*
