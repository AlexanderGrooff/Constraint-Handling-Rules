module evaluation

imports
  src-gen/signatures/-
  desugar

rules
  args-unify: ([arg1|args1*], [arg2|args2*], store*) -> <args-unify> (args1*, args2*, store2*)
    where store2* := <unify> (arg1, arg2, store*)
  args-unify: ([], [], store*) -> store*
  
  lookup-store: (x, []) -> Var(x)
  	with <debug> $[var [x] not found]
  lookup-store: (x, [(x, val) | store*]) -> val
  	with <debug> $[found value for [x]]
  lookup-store: (x, [_ | store*]) -> <lookup-store> (x, store*)
  
  substitute: (Atom(x), store*) -> Atom(x)
  substitute: (Int(x), store*) -> Int(x)
  substitute: (Float(x), store*) -> Float(x)
  substitute: (CompoundTerm(x, args*), store*) -> CompoundTerm(x, <substitute-list> (args*, store*))
  substitute: (Var(x), store*) -> <lookup-store> (x, store*)
  substitute: (String(x), store*) -> String(x)
  substitute: (Conj(a, b), store*) -> Conj(<substitute> (a, store*), <substitute> (b, store*))
  substitute-list: ([], store*) -> []
  substitute-list: ([arg | args*], store*) -> [<substitute> (arg, store*) | <substitute-list> (args*, store*)]
  
  unify-var: (Var(x), value, []) -> (x, value)
  	with <debug> $[No previous definition found of [x]]
  unify-var: (Var(x), value, [(x, value) | store*]) -> []
  	with <debug> $[Previous definition of [x] found with same value]
  unify-var: (Var(x), value, [(t, _) | store*]) -> <unify-var> (Var(x), value, store*)
    where 
      <not(?t)> x

  unify: (Atom(x), Atom(x), store*) -> store*
  unify: (Int(x), Int(x), store*) -> store*
  unify: (Float(x), Float(x), store*) -> store*
  unify: (String(x), String(x), store*) -> store*
  unify: (Atom(x), String(x), store*) -> store*
  unify: (String(x), Atom(x), store*) -> store*
  unify: (CompoundTerm(x, args1*), CompoundTerm(x, args2*), store*) -> <args-unify> (args1*, args2*, store*)
    where <eq>(<length> args1*, <length> args2*)
  unify: (Var(x), goal, store*) -> [<unify-var> (Var(x), goal, store*) |store*]
  unify: (head, Var(x), store*) -> [<unify-var> (Var(x), head, store*) |store*]

  evaluate(|rulls*): (_, Atom("true"), store*) -> ("true", store*)
  evaluate(|rulls*): (_, Conj(goal1, goal2), store*) -> ("true", store3*)
    where (str, store2*) := <evaluate(|rulls*)> (rulls*, goal1, store*);
    	<eq>(str, "true");
    	<debug> $[Evaluating second part of Conj];
      	(str2, store3*) :=<evaluate(|rulls*)> (rulls*, goal2, store2*);
      	<eq>(str2, "true")
  evaluate(|rulls*): (_, Conj(goal1, goal2), store*) -> ("false", store*)
  evaluate(|rulls*): (_, Disj(goal1, goal2), store*) -> ("true", store2*)
    where (str, store2*) := <evaluate(|rulls*)> (rulls*, goal1, store*);
    	<eq>(str, "true")
  evaluate(|rulls*): (_, Disj(goal1, goal2), store*) -> ("true", store2*)
    where (str, store2*) := <evaluate(|rulls*)> (rulls*, goal2, store*);
    	<eq>(str, "true")
  evaluate(|rulls*): (_, Disj(goal1, goal2), store*) -> ("false", store*)
  evaluate(|rulls*): (_, Neg(goal), store*) -> ("false", store*)
    where (str, new-store*) := <evaluate(|rulls*)> (rulls*, goal, store*);
    	<eq>(str, "true")
  evaluate(|rulls*): (_, Neg(goal), store*) -> ("true", store*)
  evaluate(|rulls*): ([Rule(head, body) | remainingrules*], goal, store*) -> (<Fst><evaluate(|rulls*)> (rulls*, subgoal, store*), new-store*)
    where 
    	<debug>$[Unify args:];
    	<debug>(head, goal, store*);
    	<debug>$[Unify result:];
    	new-store*  := <debug> <unify> (head, goal, store*);
    	<debug>$[Substitute result:];
      	subgoal := <debug><substitute>(body, new-store*)
  evaluate(|rulls*): ([Rule(head, body) | remainingrules*], goal, store*) -> (<Fst><evaluate(|rulls*)> (remainingrules*, goal, store*),store*)
  evaluate(|rulls*): ([], _, store*) -> ("false", store*)

		

  evaluate-full: (rulls*, Query(goal)) -> <evaluate(|desugared-rules*)> (desugared-rules*, <desugar-all>goal, [])
  	with
  		desugared-rules* := <desugar-all> rulls*
