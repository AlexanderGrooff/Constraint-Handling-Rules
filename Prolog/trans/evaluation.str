module evaluation

imports
  src-gen/signatures/-
  desugar

rules
  args-unify: ([arg1|args1*], [arg2|args2*], local-store*, free-store*) -> <args-unify> (args1*, args2*, local-store2*, free-store2*)
    where (local-store2*, free-store2*) := <unify> (arg1, arg2, local-store*, free-store*)
  args-unify: ([], [], local-store*, free-store*) -> (local-store*, free-store*)
  
  lookup-store: (x, []) -> Var(x)
  	with <debug> $[var [x] not found]
  lookup-store: (x, [(x, val) | store*]) -> val
  	with <debug> $[found value for [x]]
  lookup-store: (x, [_ | store*]) -> <lookup-store> (x, store*)
  
  substitute(|store*): Var(x) -> <lookup-store> (x, store*)
  
  substitute-all(|store*) = topdown(try(substitute(|store*)))
  
  unify-var: (x, value, store*) -> store*
    where <fetch(?(x, found))> store*;
          <eq> (found, value)
  	with <debug> $[Previous definition of [x] found with same value]
  unify-var: (x, value, store*) -> [(x, value) |store*]
    where <not(fetch(?(x, _)))> store*
  	with <debug> $[No previous definition found of [x]]

  unify: (Atom(x), Atom(x), local-store*, free-store*) -> (local-store*, free-store*)
  unify: (Int(x), Int(x), local-store*, free-store*) -> (local-store*, free-store*)
  unify: (Float(x), Float(x), local-store*, free-store*) -> (local-store*, free-store*)
  unify: (String(x), String(x), local-store*, free-store*) -> (local-store*, free-store*)
  unify: (Atom(x), String(x), local-store*, free-store*) -> (local-store*, free-store*)
  unify: (String(x), Atom(x), local-store*, free-store*) -> (local-store*, free-store*)
  unify: (CompoundTerm(x, args1*), CompoundTerm(x, args2*), local-store*, free-store*) -> <args-unify> (args1*, args2*, local-store*, free-store*)
    where <eq>(<length> args1*, <length> args2*)
  unify: (Var(x), goal, local-store*, free-store*) -> (new-store*, free-store*)
    where new-store* := <unify-var> (x, goal, local-store*)
  unify: (head, Var(x), local-store*, free-store*) -> (local-store*, new-store*)
    where new-store* := <unify-var> (x, head, free-store*)

  evaluate(|rulls*): (_, Atom("true"), _) -> ("true", [])
  evaluate(|rulls*): (remainingrules*, Conj(goal1, goal2), store*) -> ("true", store3*)
    where (str, store2*) := <evaluate(|rulls*)> (remainingrules*, goal1, store*);
    	<eq>(str, "true");
    	<debug> $[Evaluating second part of Conj];
      	(str2, store3*) := <evaluate(|rulls*)> (rulls*, goal2, store2*);
      	<eq>(str2, "true")
  evaluate(|rulls*): ([Rule(_, _) | remainingrules*], Conj(goal1, goal2), store*) -> <evaluate(|rulls*)> (remainingrules*, Conj(goal1, goal2), store*)
  evaluate(|rulls*): (_, Disj(goal1, goal2), store*) -> ("true", store2*)
    where (str, store2*) := <evaluate(|rulls*)> (rulls*, goal1, store*);
    	<eq>(str, "true")
  evaluate(|rulls*): (_, Disj(goal1, goal2), store*) -> ("true", store2*)
    where (str, store2*) := <evaluate(|rulls*)> (rulls*, goal2, store*);
    	<eq>(str, "true")
  evaluate(|rulls*): (_, Disj(goal1, goal2), store*) -> ("false", store*)
  evaluate(|rulls*): (_, Neg(goal), store*) -> ("false", new-store*)
    where (str, new-store*) := <evaluate(|rulls*)> (rulls*, goal, store*);
    	<eq>(str, "true")
  evaluate(|rulls*): (_, Neg(goal), store*) -> ("true", store*)
  evaluate(|rulls*): ([Rule(head, body) | remainingrules*], goal, store*) -> (r, <conc> (<substitute-all(|free-store2*)> free-store*, free-store2*))
    where 
    	<debug>$[Unify args: ];
    	<debug>(head, goal, store*);
    	(local-store*, free-store*) := <unify> (head, goal, [], store*);
    	<debug>$[Local store:];
    	<debug>local-store*;
    	<debug>$[Free store:];
    	<debug>free-store*;
      	subgoal := <substitute-all(|local-store*)> body;
    	<debug>$[Substitute result:];
    	<debug>subgoal;
    	(r, free-store2*) := <evaluate(|rulls*)> (rulls*, subgoal, []);
    	<debug>$[Free store 2:];
    	<debug>free-store2*
  evaluate(|rulls*): ([Rule(_, _) | remainingrules*], goal, store*) -> <evaluate(|rulls*)> (remainingrules*, goal, store*)
  evaluate(|rulls*): ([], _, _) -> ("false", [])

  evaluate-full: (rulls*, Query(goal)) -> <evaluate(|desugared-rules*)> (desugared-rules*, <desugar-all> goal, [])
  	with
  		desugared-rules* := <desugar-all> rulls*
